# JavaScript演習：デジタル時計 & カレンダー

## 1. 概要
JavaScriptの `Date` オブジェクトを活用して、以下の2つの機能を持つ「日付・時刻アプリ」を作成します。
1.  **デジタル時計**: 現在の日付（年月日・曜日）と時刻をリアルタイムで表示する。
2.  **カレンダー**: 当月のカレンダーを自動生成して表示する。

この演習では、日時処理の基本に加え、機能ごとに関数を分けて記述する「ロジックの分割（モジュール化の基礎）」を実践します。

## 2. 要件定義

### 2.1 デジタル時計機能
- **表示内容**:
    - 日付: `YYYY年MM月DD日(曜日)` の形式（例: `2026年1月18日(日)`）
    - 時刻: `HH:mm:ss` の形式（例: `14:05:09`）
    - ※時刻の「時・分・秒」が1桁の場合は、先頭に `0` を付けて常に2桁で表示すること（ゼロパディング）。
- **更新頻度**:
    - 1秒ごとに表示を自動更新する。

### 2.2 カレンダー機能
- **表示内容**:
    - アプリ起動時の「現在の年・月」のカレンダーを表示する。
    - 日曜日始まりの表形式（テーブル）とする。
    - 今日の日付のセルには、目立つスタイル（背景色を変えるなど）を適用する。
    - （今回は月切り替えボタン等は必須とせず、当月表示のみでOKとします）

## 3. 配布ファイル構成
```
calendar/
├── index.html   (HTML雛形：Bootstrap読込済み、時計・カレンダーの配置場所)
├── style.css    (カレンダーのスタイル定義)
└── script.js    (関数の枠組みのみ定義済み)
```

## 4. 実装ステップ

### Step 1: デジタル時計の実装
1.  `script.js` の `updateClock()` 関数を実装します。
2.  `new Date()` で現在日時を取得します。
3.  年、月、日、曜日、時、分、秒をそれぞれ取得します。
    - **注意**: `getMonth()` は `0`（1月）〜 `11`（12月）を返すため、表示用に `+1` する必要があります。
    - **注意**: `getDay()` は `0`（日曜）〜 `6`（土曜）の数値を返すため、配列 `["日", "月", ...]` を使って漢字に変換します。
4.  時・分・秒が1桁の場合、文字列の先頭に `"0"` を追加して `slice(-2)` するなどで2桁に揃えます。
5.  作成した文字列を `index.html` の所定の要素（`#current-date`, `#current-time`）にセットします。
6.  `init()` 関数内で `setInterval` を使い、`updateClock` を呼び出すように設定します。

    > [!WARNING]
    > **タイマーの誤差について**
    > `setInterval(..., 1000)` で1000ミリ秒（1秒）ごとに更新すると、処理時間の影響で少しずつ実行タイミングが遅れていく「誤差（ドリフト）」が発生します。
    > これを防ぐための効果的な対策（カウンターメジャー）として、今回は以下のアプローチを推奨します。
    > *   **更新間隔を短くする**: 
    >     1秒ごとではなく、**100〜200ミリ秒ごと**に更新関数を実行します。
    >     `new Date()` で取得する「秒」が変わらない限り表示は変わりませんが、「秒」が変わった瞬間に近いタイミングで描画更新できるようになり、体感的なズレを解消できます。

### Step 2: カレンダーロジックの考察
JavaScriptでカレンダーを作るには、以下の2つの情報が必要です。
1.  **月初めの曜日**: その月の「1日」が何曜日か？（これで最初の空白セルの数が決まる）
2.  **月末の日付**: その月が「何日まで」あるか？（28, 29, 30, 31日）

**ヒント:**
- `new Date(year, month - 1, 1).getDay()` で、指定月の1日の曜日インデックス（0:日〜6:土）が取得できます。
- `new Date(year, month, 0).getDate()` で、指定月の「前月の最終日」ではなく、「当月の最終日（正しくは翌月の0日目＝当月末）」が取得できます。

### Step 3: カレンダー描画の実装
1.  `script.js` の `generateCalendar(year, month)` 関数を実装します。
2.  Step 2のヒントを使って、描画に必要なループ回数などを計算します。
3.  `<tr>`（行）と `<td>`（セル）を生成しながら、HTML文字列を構築（またはDOM生成）します。
    - 最初の週は、1日の曜日になるまで空のセル `<td></td>` を埋めます。
    - 日付を1から末日まで順に埋めていきます。
    - 土曜日（曜日インデックスが6）になったら、新しい行 `<tr>` に切り替えます。
4.  生成したHTMLを `#calendar-body` に挿入します。

## 5. 発展課題（余裕があれば）
- 「今日」の日付セルに `class="today"` を付与して、色を変えてみましょう。
- 土曜日のセルを青、日曜日のセルを赤にするスタイルを適用してみましょう。

---

### [コラム] より正確なタイマーを作るには？（発展）
`setInterval` は手軽ですが、長期間動かし続けると誤差が蓄積する性質があります。
より厳密な精度が求められる場合（例：音楽ゲーム、計測アプリ）は、**「再帰的な `setTimeout`」** と **「時間の自己補正」** を組み合わせる手法が使われます。

```javascript
let nextTime = Date.now() + 1000; // 次に実行すべき予定時刻

function updateClockRecursive() {
    // ...時計更新処理...

    // 予定時刻と現在時刻の差分（＝遅れ）を計算し、次の待ち時間を調整する
    let delay = nextTime - Date.now();
    nextTime += 1000; // 次の予定時刻をセット
    
    // 遅れを取り戻すように少し短めに待機する
    setTimeout(updateClockRecursive, Math.max(0, delay));
}
```
「予定していた時間」に対して「どれくらい遅れたか」を毎回計算し、次の休憩時間を短くすることで遅れを取り戻す仕組みです。興味があれば調べてみましょう。
